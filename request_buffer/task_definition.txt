Request Buffer
Често се налага да се правят време-отнемащи задачи които ще наречем заявки.
Резултата от тези задачи често може да бъде запазен и използван вместо отново да се изпълняват
същите задачи. Това се нарича кеширанe. В допълнение е възможно докато се изпълнява задача да се
получат заявки за същата задача, преди първата такава да е приключила. В такъв случай искаме само
първата наистина да се 'извърши', а останалите да изчакат и използват резултата ѝ на готово.

Имайки следния интерфейс, описващ една заявка:

type Request interface{
    // Връща идентификатор за заявката. Ако две заявки имат еднакви идентификатори
    // то те са "равни".
    ID() string

    // Блокира докато изпълнява заявката.
    // Връща резултата или грешка ако изпълнението е неуспешно.
    // Резултата и грешката не трябва да бъдат подавани на SetResult
    // за текущата заявка - те са запазват вътрешно преди да бъдат върнати.
    Run() (result interface{}, err error)

    // Връща дали заявката е кешируерма.
    // Метода има неопределено поведение ако бъде извикан преди `Run`.
    Cacheable() bool

    // Задава резултата на заявката.
    // Не трябва да се извиква за заявки, за които е бил извикан `Run`.
    SetResult(result interface{}, err error)
}
Вашата задача е да имплементирате следния интерфейс:

type Requester interface{
    // Добавя заявка за изпълнение и я изпълнява, ако това е необходимо, при първа възможност.
    AddRequest(request Request)

    // Спира 'Заявчика'. Това означава че изчаква всички вече започнали заявки да завършат
    // и извиква `SetResult` на тези заявки които вече са били добавени, но "равни" на тях вече са
    // били изпълнявание.
    // Нови заявки не трябва да бъдат започвани през това време, нито ако вече започнати равни на
    // тях да бъдат добавяни за извиквани на `SetResult`.
    Stop()
}
Както и функция(конструктор):

// Връща нов заявчик, която кешира отговорите на до cacheSize заявки,
// изпълнявайке не повече от throttleSize заявки едновременно.
func NewRequester(cacheSize int, throttleSize int) Requester
Уточнения:

Алгоритъмът за работа с вече запълнен кеш е "заместване на най-стария резултат", познат още като
цикличен буфер. Всякакви други алгоритми не сe приемат.
Ако се получи втора заявка, която да е същата като текущо обработваната се очаква че:
Ще се изчака текущо изпълняващата се за да се види дали не е кешируема.
Ако не е кешируема то заявката трябва да бъде изпълнена все едно не е имало такава със същото ID.
Aко Cacheable върне true, то това означава че тази заявка може да бъде кеширана. Отговора ѝ може да
бъде използван от всички други "равни" на нея.
Ако Cacheable върне false, то това означава че заявката не може да бъде кеширана. Ако докато се е
изпълнявала са дошли още 5 заявки със същото ID - то те трябва да я изчакат да видят дали няма да e
кешируема.
Run или SetRequest приключва дадена заявка. Викането на единия и след това другия метод както и
много кратното извикване на един от тях за една съща заявка има неопределено поведение - не го правете.
ВАЖНО: интерфейсите Requester и Request ще трябва да бъдат копирани в кода на решението ви.
При извикването на тестовете в директорията трябва да има два файла solution_test.go с тестовете и
вашото решение solution.go в което двата интерфейса са копирани.

Пример 1:

    var req1, req2, req3 Request
    // инициализиране на req1, req2, req3 да са 3 "равни" Request-а, за които Cacheable връща true.
    requester := NewRequester(1, 1)
    requester.AddRequest(req1)
    go func() {
        requester.AddRequest(req2) // (1)
        requester.AddRequest(req3) // (2)
    }
    requester.Stop() // (3)
1. req1 бива изпъленен чрез извикване на Run
2. Ако (3) се изпълни преди (1): req2 и req3 не биват изпълнявани - нито `Run` нито `SetResult` биват извиквани за тях.
3. Ако (3) се изпълни след (1) (и (2)): то за req2 (и req3) трябва да бъде извикан само `SetResult`